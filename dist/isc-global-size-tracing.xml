<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="26" zv="IRIS for UNIX (Ubuntu Server LTS for x86-64 Containers) 2020.4 (Build 521U)" ts="2020-11-25 13:34:06">
<Class name="Iris.Tools.Monitor.Dao.DBSizeDAO">
<TimeChanged>65708,48794.741521</TimeChanged>
<TimeCreated>65708,48794.741521</TimeCreated>

<Method name="setSize">
<Description>
Insert or update a database size record.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>recordType:%String,database:%String,dbSizeInMB:%Float,freeSpaceInMB:%Float,diskFreeSpaceInMB:%Float,sizeDate:%Date=+$h</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK
	Set uHlp =##class(Iris.Tools.Monitor.Data.DBSize).cmUHlpGet(.recordType,.sizeDate)
	Set sizeRecord = ##class(Iris.Tools.Monitor.Data.DBSize).uniqueIOpen(.uHlp,.database,.recordType)
	Set:'$Isobject(sizeRecord) sizeRecord = ##class(Iris.Tools.Monitor.Data.DBSize).%New()
	Set sizeRecord.recordType = recordType
	Set sizeRecord.database = database
	Set sizeRecord.dbSizeInMB = dbSizeInMB
	Set sizeRecord.sizeDate = sizeDate
	Set sizeRecord.freeSpaceInMB = freeSpaceInMB
	Set sizeRecord.diskFreeSpaceInMB = diskFreeSpaceInMB
	Set sc = sizeRecord.%Save()
	Set sizeRecord = ""
	return sc
]]></Implementation>
</Method>

<Method name="updateDBSizeInfo">
<ClassMethod>1</ClassMethod>
<FormalSpec>mask:%String="*"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK
	Set tStatement = ##class(%SQL.Statement).%New()
	Set sc = tStatement.%PrepareClassQuery("%SYS.DatabaseQuery","FreeSpace")
	If $$$ISERR(sc) $$$ThrowStatus(sc)
	Set tResult = tStatement.%Execute(mask)
	If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
	Set sizeDate = +$h
	While tResult.%Next() {
		$$$TOE(tSc,..setSize("Day",tResult.%Get("Directory"),..convertInMB(tResult.%Get("Size")),tResult.%Get("Free"),..convertInMB(tResult.%Get("DiskFreeSpace")),sizeDate))
		$$$TOE(tSc,..setSize("Week",tResult.%Get("Directory"),..convertInMB(tResult.%Get("Size")),tResult.%Get("Free"),..convertInMB(tResult.%Get("DiskFreeSpace")),sizeDate))
		$$$TOE(tSc,..setSize("Month",tResult.%Get("Directory"),..convertInMB(tResult.%Get("Size")),tResult.%Get("Free"),..convertInMB(tResult.%Get("DiskFreeSpace")),sizeDate))
		$$$TOE(tSc,..setSize("Year",tResult.%Get("Directory"),..convertInMB(tResult.%Get("Size")),tResult.%Get("Free"),..convertInMB(tResult.%Get("DiskFreeSpace")),sizeDate))
	}
	Kill tResult,tStatement
	Return tSc
]]></Implementation>
</Method>

<Method name="convertInMB">
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Float</ReturnType>
<Implementation><![CDATA[
	Set unit = $Extract(size,*-1,*)
	Set fSize = $Extract(size,1,*-2)
	Set coef = $s(unit="MB":1,unit="GB":1024,unit="TB":1024**2,unit="KB":1/1024,1:doh/*force an error*/)
	Return fSize*coef
]]></Implementation>
</Method>

<Method name="get">
<Description><![CDATA[
Usefull method to retrieve size of database, following filters : <br/><ul>
<li><b>database</b>: database directory ("*" are allowed for all databases).</li>
<li><b>recordType</b>: possible value Day,Week,Month,Year</li>
<li><b>startDate</b>: start date in %Date format</li>
<li><b>endDate</b>: end date in %Date format</li>
</ul>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String,recordType:%String,startDate:%Date,endDate:%Date=+$h</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set response = []
	Set tStatement = ##class(%SQL.Statement).%New()
	Set sc = tStatement.%PrepareClassQuery("Iris.Tools.Monitor.Dao.DBSizeDAO","FilterDBSize")
	If $$$ISERR(sc) $$$ThrowStatus(sc)
	Set tResult = tStatement.%Execute(.database,.recordType,.startDate,.endDate)
	If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
	While tResult.%Next() {
		Set tObj = ..getDTO(tResult.%Get("database"),
							tResult.%Get("sizeDate"),
							tResult.%Get("dbSizeInMB"),
							tResult.%Get("freeSpaceInMB"),
							tResult.%Get("diskFreeSpaceInMB"),
							tResult.%Get("tsUpdate"),
							tResult.%Get("tsCreate"),
							tResult.%Get("Year"),
							tResult.%Get("Month"),
							tResult.%Get("Week"),
							tResult.%Get("uHlp"))
		Do response.%Push(tObj)
	}
	Kill tResult,tStatement
	Return response
]]></Implementation>
</Method>

<Method name="getDTOFromObj">
<Description>
Return a dynamic object from DBSize object.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>sizeRecord:Iris.Tools.Monitor.Data.DBSize</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Return {
		"database":(sizeRecord.database),
		"sizeDate":($zd(sizeRecord.sizeDate,3)),
		"dbSizeInMB":(sizeRecord.dbSizeInMB),
		"freeSpaceInMB":(sizeRecord.freeSpaceInMB),
		"diskFreeSpaceInMB":(sizeRecord.diskFreeSpaceInMB),
		"tsUpdate":(sizeRecord.tsUpdate),
		"tsCreate":(sizeRecord.tsCreate),
		"year":(sizeRecord.year),
		"month":(sizeRecord.month),
		"week":(sizeRecord.week),
		"uHlp":(sizeRecord.uHlp)
	}
]]></Implementation>
</Method>

<Method name="getDTO">
<Description>
Return a dynamic object from DBSize data.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String,sizeDate:%Date,dbSizeInMB:%Float,freeSpaceInMB:%Float,diskFreeSpaceInMB:%Float,tsUpdate:%TimeStamp,tsCreate:%TimeStamp,year:%Integer,month:%Integer,week:%Integer,uHlp:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Return {
		"database":(database),
		"sizeDate":($zd(sizeDate,3)),
		"dbSizeInMB":(dbSizeInMB),
		"freeSpaceInMB":(freeSpaceInMB),
		"diskFreeSpaceInMB":(diskFreeSpaceInMB),
		"tsUpdate":(tsUpdate),
		"tsCreate":(tsCreate),
		"year":(year),
		"month":(month),
		"week":(week),
		"uHlp":(uHlp)
	}
]]></Implementation>
</Method>

<Method name="exportToFile">
<Description><![CDATA[
Perform the same operation as <b>get</b> method and store the result in a CSV file.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>fileName:%String,database:%String,recordType:%String,startDate:%Date,endDate:%Date</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set dir = ##class(%File).GetDirectory(fileName)
	Do:##class(%File).DirectoryExists(dir) ##class(%File).CreateDirectoryChain(dir)
	Set file=##class(%File).%New(fileName)
	Do file.Open("WSN")
	Set sc = ..exportToStream(.file,.database,.recordType,.startDate,.endDate)
	Return sc
]]></Implementation>
</Method>

<Method name="exportToStream">
<Description><![CDATA[
Perform the same operation as <b>get</b> method and store  result to a stream.
]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&stream:%Stream.GlobalCharacter=##class(%Stream.GlobalCharacter).%New(),database:%String,recordType:%String,startDate:%Date,endDate:%Date]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, sep = ";"
	Set tStatement = ##class(%SQL.Statement).%New()
	Set sc = tStatement.%PrepareClassQuery("Iris.Tools.Monitor.Dao.DBSizeDAO","FilterDBSize")
	Return:'sc sc
	Set tResult = tStatement.%Execute(.database,.recordType,.startDate,.endDate)
	Return:(tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ERROR($$$SQLError, tResult.%SQLCODE,tResult.%Message)
	Set sc = ##class(Iris.Tools.Monitor.Dao.UtilsDAO).rsToCSVStream(.stream,.tResult)
	Kill tStatement,tResult
	Return sc
]]></Implementation>
</Method>

<Method name="getAllDB">
<Description>
Return the list of database directory on this system.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set ns = $namespace, dbList = ""
	Try{
		Set $namespace = "%SYS", rs=##class(%Library.ResultSet).%New("Config.Databases:List")
		Do rs.Execute()
		While rs.Next() {
			Set $List(dbList,$i(i))=rs.Data("Directory")
		}
		Do rs.Close()
		Set $namespace = ns
	}Catch(ex) {
		Set $namespace = ns
		Throw ex
	}
	Return dbList
]]></Implementation>
</Method>

<Query name="FilterDBSize">
<Type>%Query</Type>
<FormalSpec>database:%String,recordType:%String,startDate:%Date,endDate:%Date</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="database:%String,dbSizeInMB:%Float,freeSpaceInMB:%Float,diskFreeSpaceInMB:%Float,tsUpdate:%TimeStamp,tsCreate:%TimeStamp,Year:%Integer,Month:%Integer,Week:%Integer,sizeDate:%Date,uHlp:%Integer,tsDate:%TimeStamp"/>
</Query>

<Method name="FilterDBSizeExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,database:%String,recordType:%String,startDate:%Date,endDate:%Date]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set startUHlp = ##class(Iris.Tools.Monitor.Data.DBSize).cmUHlpGet(.recordType,.startDate)
    Set endUHlp = ##class(Iris.Tools.Monitor.Data.DBSize).cmUHlpGet(.recordType,.endDate)
    Set tSql = "SELECT database,dbSizeInMB,freeSpaceInMB,diskFreeSpaceInMB,tsUpdate,tsCreate,Year,Month,Week,sizeDate,uHlp "
    			_"FROM Iris_Tools_Monitor_Data.DBSize "
    			_"WHERE uHLP >= ? AND uHLP <= ? "
    			_$s($lv(database):"and database %INLIST ? ",database'="*":"and database = ? ",1:"")
    			_"and recordType = ?"
    Set params($i(params))=startUHlp
    Set params($i(params))=endUHlp
    Set:database'="*" params($i(params))=database
    Set params($i(params))=recordType
    Set tStatement = ##class(%SQL.Statement).%New()
    Set sc = tStatement.%Prepare(.tSql)
	;Set ^CacheTempDBSizeLast("sql")=tSql
	;Merge ^CacheTempDBSizeLast("args") = params
    Set tResult = tStatement.execute(params...) ; ^lsc:No %Execute for passing array.  The first time I have bitten my keyboard... GoTo Read %SQL.Statement code for understanding.
    Return:(tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message) 
    Set qHandle=tResult
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="FilterDBSizeFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>FilterDBSizeExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tResult=qHandle, sc = $$$OK
	If 'tResult.%Next() {
		Set AtEnd = 1, Row = ""
	}Else{
		Set Row = $Listbuild(tResult.%Get("database"),tResult.%Get("dbSizeInMB"),tResult.%Get("freeSpaceInMB"),tResult.%Get("diskFreeSpaceInMB"),tResult.%Get("tsUpdate"),tResult.%Get("tsCreate"),tResult.%Get("Year"),tResult.%Get("Month"),tResult.%Get("Week"),tResult.%Get("sizeDate"),tResult.%Get("uHlp"),$zd(tResult.%Get("sizeDate"),3))
	}
	Return sc
]]></Implementation>
</Method>

<Method name="FilterDBSizeClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>FilterDBSizeFetch</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle=""
    Return $$$OK
]]></Implementation>
</Method>

<Method name="clean">
<Description><![CDATA[
 <b>!NOT TESTED ! Todo ...</b>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>retDay:%Integer=90,retWeek:%Integer=24,retMonth:%Integer=-1,retYear:%Integer=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK,
			whereStr =" (uHlp < ? AND recordType= ?) OR",
			tSql($i(tSql)) = "DELETE Iris_Tools_Monitor_Data.DBSize WHERE ",
			tArgs=0
	
	If retDay'=-1 {
		Set uHlp = ##class(Iris.Tools.Monitor.Data.DBSize).cmUHlpGet("Day",$h-retDay)
		Set tSql($i(tSql)) = whereStr, tArgs($i(tArgs))=uHlp, tArgs($i(tArgs))="Day"	
	}
	
	If retWeek'=-1 {
		Set uHlp = ##class(Iris.Tools.Monitor.Data.DBSize).cmUHlpGet("Week",$h-(retWeek*7))
		Set tSql($i(tSql)) = whereStr, tArgs($i(tArgs))=uHlp, tArgs($i(tArgs))="Week"
	}
	
	If retMonth'=-1 {
		Set uHlp = ##class(Iris.Tools.Monitor.Data.DBSize).cmUHlpGet("Month",$zdh($SYSTEM.SQL.DATEADD("mm",-retMonth,+$h),3))
		Set tSql($i(tSql)) = whereStr, tArgs($i(tArgs))=uHlp, tArgs($i(tArgs))="Month"
	}
	
	If retYear'=-1 {
		Set uHlp = ##class(Iris.Tools.Monitor.Data.DBSize).cmUHlpGet("Year",$zdh($SYSTEM.SQL.DATEADD("yy",-retYear,+$h),3))
		Set tSql($i(tSql)) = whereStr, tArgs($i(tArgs))=uHlp, tArgs($i(tArgs))="Year"
	}
	
	If tSql>1 {
		Set tSql(tSql)=$Extract(tSql(tSql),1,*-2) ; delete last "OR"
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%Prepare(.tSql)
		Return:'sc sc
		Set tResult = tStatement.execute(tArgs...)
		Set:(tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) sc = $$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message) 
	}
	Return sc
]]></Implementation>
</Method>
</Class>


<Class name="Iris.Tools.Monitor.Dao.GlobalSizeDAO">
<TimeChanged>65708,48794.737532</TimeChanged>
<TimeCreated>65708,48794.737532</TimeCreated>

<Method name="getGlobalList">
<Description>
Return a list of global for a database directory.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set gblList = "", gbl = ""
	Do ..clearGblListCache(database)
	For  {
		Set gbl = ..getNextGlobal(.database,gbl)
		w database, gbl,!
		Quit:gbl=""
		Set $List(gblList,$i(i))=gbl
	}
	Return gblList
]]></Implementation>
</Method>

<Method name="getNextGlobal">
<Description>
Expression for iterate on existing global on a database.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String,gbl:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	; $Order(^$["^^"_database]GLOBAL(gbl))	;broken
	Return:$Data(^||tmpGlobalList(database)) $Order(^||tmpGlobalList(database,gbl))
	Set tStatement = ##class(%SQL.Statement).%New()
	Set sc = tStatement.%PrepareClassQuery("%SYS.GlobalQuery","DirectoryList")
	If $$$ISERR(sc) $$$ThrowStatus(sc)
	Set tResult = tStatement.%Execute(.database)
	If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
	While tResult.%Next() {
		Set ^||tmpGlobalList(database,tResult.%Get("Name"))=""
	}
	Kill tResult,tStatement
	Return $Order(^||tmpGlobalList(database,gbl))
]]></Implementation>
</Method>

<Method name="clearGblListCache">
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill ^||tmpGlobalList(database)
	Return $$$OK
]]></Implementation>
</Method>

<Method name="setSize">
<Description>
Insert or update a globalSize record.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>recordType:%String,database:%String,global:%String,allocatedInMB:%Float,sizeDate:%Date=+$h</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set uHlp =##class(Iris.Tools.Monitor.Data.GlobalSize).cmUHlpGet(.recordType,.sizeDate)
	Set sizeRecord = ##class(Iris.Tools.Monitor.Data.GlobalSize).uniqueIOpen(.uHlp,.global,.database,.recordType)
	Set:'$Isobject(sizeRecord) sizeRecord = ##class(Iris.Tools.Monitor.Data.GlobalSize).%New()
	Set sizeRecord.recordType = recordType
	Set sizeRecord.database = database
	Set sizeRecord.global = global
	Set sizeRecord.allocatedInMB = allocatedInMB
	Set sizeRecord.sizeDate = sizeDate
	Set sc = sizeRecord.%Save()
	Set sizeRecord = ""
	return sc
]]></Implementation>
</Method>

<Method name="getTopGlobals">
<ClassMethod>1</ClassMethod>
<FormalSpec>top:%Integer,database:%String,recordType:%String="Day"</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set tSql = "SELECT sql_global "
    			_"FROM Iris_Tools_Monitor_Data.GlobalSize "
    			_"WHERE database = ? "
    			_"and recordType = ? "
				_"order by uHLP DESC, allocatedInMB DESC"

	Set tStatement = ##class(%SQL.Statement).%New()
	Set sc = tStatement.%Prepare( tSql )
	
	Set tResult = tStatement.%Execute(.database,.recordType)
	If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 

	Set list = "", cnt = 0

	While tResult.%Next() {
		Set $List(list, $Increment(cnt) ) = tResult.%Get("sql_global")
		Quit:cnt=top
	}

	Return list
]]></Implementation>
</Method>

<Method name="get">
<Description><![CDATA[
Usefull method to retrieve size of global data, following filters : <br/><ul>
<li><b>database</b>: database directory ("*" are allowed for all databases).</li>
<li><b>global</b>: global name (with the "^" character, "*" are allowed for all globals)</li>
<li><b>recordType</b>: possible value Day,Week,Month,Year</li>
<li><b>startDate</b>: start date in %Date format</li>
<li><b>endDate</b>: end date in %Date format</li>
</ul>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String,global:%String="*",recordType:%String,startDate:%Date,endDate:%Date=+$h</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set response = []
	Set tStatement = ##class(%SQL.Statement).%New()
	Set sc = tStatement.%PrepareClassQuery("Iris.Tools.Monitor.Dao.GlobalSizeDAO","FilterGlobalSize")
	If $$$ISERR(sc) $$$ThrowStatus(sc)

	Set tResult = tStatement.%Execute(.database,.global,.recordType,.startDate,.endDate)
	If (tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ThrowStatus($$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message)) 
	While tResult.%Next() {
		Set tObj = ..getDTO(tResult.%Get("database"),
							tResult.%Get("global"),
							tResult.%Get("sizeDate"),
							tResult.%Get("allocatedInMB"),
							tResult.%Get("tsUpdate"),
							tResult.%Get("tsCreate"),
							tResult.%Get("Year"),
							tResult.%Get("Month"),
							tResult.%Get("Week"),
							tResult.%Get("uHlp"))
		Do response.%Push(tObj)
	}
	Kill tResult,tStatement
	Return response
]]></Implementation>
</Method>

<Method name="getDTO">
<Description>
Return a dynamic object from GlobalSize data.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String,global:%String,sizeDate:%Date,allocatedInMB:%Float,tsUpdate:%TimeStamp,tsCreate:%TimeStamp,year:%Integer,month:%Integer,week:%Integer,uHlp:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Return {
		"database":(database),
		"global":(global),
		"sizeDate":($zd(sizeDate,3)),
		"allocatedInMB":(allocatedInMB),
		"tsUpdate":(tsUpdate),
		"tsCreate":(tsCreate),
		"year":(year),
		"month":(month),
		"week":(week),
		"uHlp":(uHlp)
	}
]]></Implementation>
</Method>

<Method name="getDTOFromObj">
<Description>
Return a dynamic object from GlobalSize object.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>sizeRecord:Iris.Tools.Monitor.Data.GlobalSize</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Return {
		"database":(sizeRecord.database),
		"global":(sizeRecord.global),
		"sizeDate":($zd(sizeRecord.sizeDate,3)),
		"allocatedInMB":(sizeRecord.allocatedInMB),
		"tsUpdate":(sizeRecord.tsUpdate),
		"tsCreate":(sizeRecord.tsCreate),
		"year":(sizeRecord.year),
		"month":(sizeRecord.month),
		"week":(sizeRecord.week),
		"uHlp":(sizeRecord.uHlp)
	}
]]></Implementation>
</Method>

<Method name="getAllDB">
<Description><![CDATA[
Return the list of database directory on this system.<br/>
Deprecated use ##class(Iris.Tools.Monitor.Dao.DBSizeDAO).getAllDB()]]></Description>
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<CodeMode>call</CodeMode>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[##class(Iris.Tools.Monitor.Dao.DBSizeDAO).getAllDB()
]]></Implementation>
</Method>

<Method name="exportToFile">
<Description><![CDATA[
Perform the same operation as <b>get</b> method and store the result in a CSV file.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>fileName:%String,database:%String,global:%String,recordType:%String,startDate:%Date,endDate:%Date</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set dir = ##class(%File).GetDirectory(fileName)
	Do:##class(%File).DirectoryExists(dir) ##class(%File).CreateDirectoryChain(dir)
	Set file=##class(%File).%New(fileName)
	Do file.Open("WSN")
	Set sc = ..exportToStream(.file,.database,.global,.recordType,.startDate,.endDate)
	Return sc
]]></Implementation>
</Method>

<Method name="exportToStream">
<Description><![CDATA[
Perform the same operation as <b>get</b> method and store  result to a stream.
]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&stream:%Stream.GlobalCharacter=##class(%Stream.GlobalCharacter).%New(),database:%String,global:%String,recordType:%String,startDate:%Date,endDate:%Date]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK, sep = ";"
	Set tStatement = ##class(%SQL.Statement).%New()
	Set sc = tStatement.%PrepareClassQuery("Iris.Tools.Monitor.Dao.GlobalSizeDAO","FilterGlobalSize")
	Return:'sc sc
	Set tResult = tStatement.%Execute(.database,.global,.recordType,.startDate,.endDate)
	Return:(tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ERROR($$$SQLError, tResult.%SQLCODE,tResult.%Message)
	Set sc = ##class(Iris.Tools.Monitor.Dao.UtilsDAO).rsToCSVStream(.stream,.tResult)
	Kill tStatement,tResult
	Return sc
]]></Implementation>
</Method>

<Query name="FilterGlobalSize">
<Type>%Query</Type>
<FormalSpec>database:%String,global:%String,recordType:%String,startDate:%Date,endDate:%Date</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="database:%String,global:%String,allocatedInMB:%Float,tsUpdate:%TimeStamp,tsCreate:%TimeStamp,Year:%Integer,Month:%Integer,Week:%Integer,sizeDate:%Date,uHlp:%Integer,tsDate:%TimeStamp"/>
</Query>

<Method name="FilterGlobalSizeExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,database:%String,global:%String,recordType:%String,startDate:%Date,endDate:%Date]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set startUHlp = ##class(Iris.Tools.Monitor.Data.GlobalSize).cmUHlpGet(.recordType,.startDate)
    Set endUHlp = ##class(Iris.Tools.Monitor.Data.GlobalSize).cmUHlpGet(.recordType,.endDate)
    Set tSql = "SELECT database,sql_global,allocatedInMB,tsUpdate,tsCreate,Year,Month,Week,sizeDate,uHlp "
    			_"FROM Iris_Tools_Monitor_Data.GlobalSize "
    			_"WHERE uHLP >= ? AND uHLP <= ? "
    			_$s($lv(database):"and database %INLIST ? ",database'="*":"and database = ? ",1:"")
    			_$s($lv(global):"and sql_global %INLIST ? ",global'="*":"and sql_global = ? ",1:"")
    			_"and recordType = ? "
	
    Set params($i(params))=startUHlp
    Set params($i(params))=endUHlp
    Set:database'="*" params($i(params))=database
    Set:global'="*" params($i(params))=global
    Set params($i(params))=recordType
    Set tStatement = ##class(%SQL.Statement).%New()
    Set sc = tStatement.%Prepare(.tSql)
	Set tResult = tStatement.execute(params...) ; ^lsc:No %Execute for passing array.  The first time I have bitten my keyboard... GoTo Read %SQL.Statement code for understanding.
    Return:(tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) $$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message) 
    Set qHandle(1)=tResult
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FilterGlobalSizeFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>FilterGlobalSizeExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tResult=qHandle(1), sc = $$$OK
	If 'tResult.%Next() {
		Set AtEnd = 1
		Set Row = ""
	}Else{
		Set Row = $Listbuild(tResult.%Get("database"),tResult.%Get("sql_global"),tResult.%Get("allocatedInMB"),tResult.%Get("tsUpdate"),tResult.%Get("tsCreate"),tResult.%Get("Year"),tResult.%Get("Month"),tResult.%Get("Week"),tResult.%Get("sizeDate"),tResult.%Get("uHlp"),$zd(tResult.%Get("sizeDate"),3))
	}
	Return sc
]]></Implementation>
</Method>

<Method name="FilterGlobalSizeClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>FilterGlobalSizeFetch</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle(1)=""
    Return $$$OK
]]></Implementation>
</Method>

<Method name="clean">
<Description><![CDATA[
 <b>!NOT TESTED ! Todo ...</b>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>retDay:%Integer=90,retWeek:%Integer=24,retMonth:%Integer=-1,retYear:%Integer=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK,
			whereStr =" (uHlp < ? AND recordType= ?) OR",
			tSql($i(tSql)) = "DELETE Iris_Tools_Monitor_Data.GlobalSize WHERE ",
			tArgs=0
	
	If retDay'=-1 {
		Set uHlp = ##class(Iris.Tools.Monitor.Data.GlobalSize).cmUHlpGet("Day",$h-retDay)
		Set tSql($i(tSql)) = whereStr, tArgs($i(tArgs))=uHlp, tArgs($i(tArgs))="Day"	
	}
	
	If retWeek'=-1 {
		Set uHlp = ##class(Iris.Tools.Monitor.Data.GlobalSize).cmUHlpGet("Week",$h-(retWeek*7))
		Set tSql($i(tSql)) = whereStr, tArgs($i(tArgs))=uHlp, tArgs($i(tArgs))="Week"
	}
	
	If retMonth'=-1 {
		Set uHlp = ##class(Iris.Tools.Monitor.Data.GlobalSize).cmUHlpGet("Month",$zdh($SYSTEM.SQL.DATEADD("mm",-retMonth,+$h),3))
		Set tSql($i(tSql)) = whereStr, tArgs($i(tArgs))=uHlp, tArgs($i(tArgs))="Month"
	}
	
	If retYear'=-1 {
		Set uHlp = ##class(Iris.Tools.Monitor.Data.GlobalSize).cmUHlpGet("Year",$zdh($SYSTEM.SQL.DATEADD("yy",-retYear,+$h),3))
		Set tSql($i(tSql)) = whereStr, tArgs($i(tArgs))=uHlp, tArgs($i(tArgs))="Year"
	}
		
	If tSql>1 {
		Set tSql(tSql)=$Extract(tSql(tSql),1,*-2) ; delete last "OR"
		Set tStatement = ##class(%SQL.Statement).%New()
		Set sc = tStatement.%Prepare(.tSql)
		Return:'sc sc
		Set tResult = tStatement.execute(tArgs...)
		Set:(tResult.%SQLCODE'=0)&&(tResult.%SQLCODE'=100) sc = $$$ERROR($$$SQLError, tResult.%SQLCODE, tResult.%Message) 
	}
	Return sc
]]></Implementation>
</Method>
</Class>


<Class name="Iris.Tools.Monitor.Dao.UtilsDAO">
<TimeChanged>65708,48794.702275</TimeChanged>
<TimeCreated>65708,48794.702275</TimeCreated>

<Method name="rsToCSVStream">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&stream:%Stream.GlobalCharacter,&rs:%SQL.StatementResult]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set line="", sep=";", meta = rs.%GetMetadata(),nbColumn = meta.columnCount
	For i=1:1:nbColumn {
		Set line = line_meta.columns.GetAt(i).colName_sep, odbcType(i)=meta.columns.GetAt(i).ODBCType
	}
	Do stream.WriteLine(line)
	While rs.%Next() {
		Set line = ""
		For i=1:1:nbColumn {
			Set data = rs.%GetData(i)
			If (odbcType(i)=8) {
				Set:($e(data,1)=".") data=0_data
				Set:$Get(%ZDecimalPointIsComma)=1 data=$Replace(data,".",",")
			} 
			Set line = line_data_sep
		}
		Do stream.WriteLine(line)
	}
	Return sc
]]></Implementation>
</Method>
</Class>


<Class name="Iris.Tools.Monitor.Data.DBSize">
<Description><![CDATA[
Peristent class designed for store the database size following one record per : <br/><ul>
<li>Day</li>
<li>Week</li>
<li>Month</li>
<li>Year</li>
</ul>]]></Description>
<Super>%Persistent,Iris.Tools.Monitor.Data.GSCommon</Super>
<TimeChanged>65708,48794.738794</TimeChanged>
<TimeCreated>65708,48794.738794</TimeCreated>

<Property name="database">
<Description>
Database directory.</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Property name="dbSizeInMB">
<Description>
Cache.dat or Iris.dat file size In Mega bytes.</Description>
<Type>%Float</Type>
<Required>1</Required>
</Property>

<Property name="freeSpaceInMB">
<Description>
Freespace on database file (in MB).</Description>
<Type>%Float</Type>
<Required>1</Required>
</Property>

<Property name="diskFreeSpaceInMB">
<Description>
Freespace on the used disk by the database file.</Description>
<Type>%Float</Type>
</Property>

<Index name="uniqueI">
<Properties>uHlp,database,recordType</Properties>
<Unique>1</Unique>
</Index>

<Method name="%OnAddToSaveSet">
<FormalSpec>depth:%Integer,insert:%Integer,callcount:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If insert {
		Set (..tsCreate,..tsUpdate) = $ZDT($h,3,1)
    }Else{
		Set ..tsUpdate = $ZDT($h,3,1)
	}
	Return $$$OK
]]></Implementation>
</Method>

<Trigger name="triggerInsert">
<Code>	Set ({tsCreate},{tsUpdate}) = $ZDT($h,3,1)</Code>
<Event>INSERT</Event>
</Trigger>

<Trigger name="triggerUpdate">
<Code>	Set {tsUpdate} = $ZDT($h,3,1)</Code>
<Event>UPDATE</Event>
</Trigger>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Iris.Tools.MonitorA859.DBSizeD</DataLocation>
<DefaultData>DBSizeDefaultData</DefaultData>
<IdLocation>^Iris.Tools.MonitorA859.DBSizeD</IdLocation>
<IndexLocation>^Iris.Tools.MonitorA859.DBSizeI</IndexLocation>
<StreamLocation>^Iris.Tools.MonitorA859.DBSizeS</StreamLocation>
<Data name="DBSizeDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>database</Value>
</Value>
<Value name="3">
<Value>dbSizeInMB</Value>
</Value>
<Value name="4">
<Value>freeSpaceInMB</Value>
</Value>
<Value name="5">
<Value>diskFreeSpaceInMB</Value>
</Value>
<Value name="6">
<Value>sizeDate</Value>
</Value>
<Value name="7">
<Value>recordType</Value>
</Value>
<Value name="8">
<Value>tsCreate</Value>
</Value>
<Value name="9">
<Value>tsUpdate</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Iris.Tools.Monitor.Data.GSCommon">
<Abstract>1</Abstract>
<TimeChanged>65708,48794.775575</TimeChanged>
<TimeCreated>65708,48794.775575</TimeCreated>

<Property name="tsCreate">
<Description>
Timestamp of record creation.</Description>
<Type>%TimeStamp</Type>
</Property>

<Property name="tsUpdate">
<Description>
Timestamp of last record update.</Description>
<Type>%TimeStamp</Type>
</Property>

<Property name="recordType">
<Description><![CDATA[
Define the record type.  For a Global & database, there are differents records
possible value are : <br/><table>
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>Day</td><td>Measure for a day (see <b>sizedate</b> property for the date)</td></tr>
<tr><td>Week</td><td>Mesasure for a week. The record is updated every day until the end of the Week</td></tr>
<tr><td>Month</td><td>Mesasure for a Month. The record is updated every day until the end of the Month</td></tr>
<tr><td>Year</td><td>Mesasure for a Year. The record is updated every day until the end of the Year</td></tr>
</table>]]></Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",Day,Week,Month,Year"/>
</Property>

<Property name="year">
<Description>
The year in 4 digits.</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {*} = ##class(Iris.Tools.Monitor.Data.GlobalSize).yearExp({sizeDate}) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Property name="month">
<Description>
The month number...</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {*} = ##class(Iris.Tools.Monitor.Data.GlobalSize).monthExp({sizeDate}) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Property name="week">
<Description>
the week number.</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {*} = ##class(Iris.Tools.Monitor.Data.GlobalSize).weekExp({sizeDate})  </SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Property name="uHlp">
<Description><![CDATA[
Special property used as an helper for record unicity and facilited SQL search.
The value depend of <b>recordType</b><br/><table>
<thead><tr><th>Recordtype</th><th>uHlp</th></tr></thead>
<tr><td>Day</td><td>sizeDate value</td></tr>
<tr><td>Week</td><td>Year concatenate with Week number in 6 digits (ex : 201914)</td></tr>
<tr><td>Month</td><td>Year concatenate with Month number in 6 digits (ex : 201904)</td></tr>
<tr><td>Year</td><td>Year in 4 digits</td></tr>
</table>]]></Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {*} = ##class(Iris.Tools.Monitor.Data.GlobalSize).cmUHlpGet({recordType},{sizeDate})</SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Property name="sizeDate">
<Description>
Date of measure.</Description>
<Type>%Date</Type>
</Property>

<Method name="yearGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Return ..yearExp(..sizeDate)
]]></Implementation>
</Method>

<Method name="monthGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Return ..monthExp(..sizeDate)
]]></Implementation>
</Method>

<Method name="weekGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Return ..weekExp(..sizeDate)
]]></Implementation>
</Method>

<Method name="uHlpGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Return ..cmUHlpGet(..recordType,..sizeDate)
]]></Implementation>
</Method>

<Method name="cmUHlpGet">
<ClassMethod>1</ClassMethod>
<FormalSpec>recordType:%String,sizeDate:%Date</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Return:recordType="Day" +sizeDate
	Return:recordType="Week" +(..yearExp(.sizeDate)_$Replace($Justify(..weekExp(.sizeDate),2)," ","0"))
	Return:recordType="Month" +(..yearExp(.sizeDate)_$Replace($Justify(..monthExp(.sizeDate),2)," ","0"))
	Return:recordType="Year" +(..yearExp(.sizeDate))
	$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("recordType %1 not implemented",recordType)))
]]></Implementation>
</Method>

<Method name="yearExp">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>sizeDate:%Date</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[+$Piece($zd(sizeDate,3),"-",1)
]]></Implementation>
</Method>

<Method name="monthExp">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>sizeDate:%Date</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[+$Piece($zd(sizeDate,3),"-",2)
]]></Implementation>
</Method>

<Method name="weekExp">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>sizeDate:%Date</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[##class(%SYSTEM.SQL).WEEK(sizeDate)
]]></Implementation>
</Method>
</Class>


<Class name="Iris.Tools.Monitor.Data.GlobalSize">
<Description><![CDATA[
Peristent class designed for store the growth of global size following one record per : <br/><ul>
<li>Day</li>
<li>Week</li>
<li>Month</li>
<li>Year</li>
</ul>]]></Description>
<Super>%Persistent,Iris.Tools.Monitor.Data.GSCommon</Super>
<TimeChanged>65708,48794.73778</TimeChanged>
<TimeCreated>65708,48794.73778</TimeCreated>

<Property name="database">
<Description>
Database reference (full directory, not database name).</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Property name="global">
<Description><![CDATA[
Global reference<br/>
Use sql_global in SQL.]]></Description>
<Type>%String</Type>
<Required>1</Required>
<SqlFieldName>sql_global</SqlFieldName>
<Parameter name="MAXLEN" value="511"/>
</Property>

<Property name="allocatedInMB">
<Description>
Allocated size for the global in MB.</Description>
<Type>%Float</Type>
<Required>1</Required>
<Parameter name="MINVAL" value="0"/>
</Property>

<Index name="uniqueI">
<Properties>uHlp,global,database,recordType</Properties>
<Unique>1</Unique>
</Index>

<Method name="%OnAddToSaveSet">
<FormalSpec>depth:%Integer,insert:%Integer,callcount:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If insert {
		Set (..tsCreate,..tsUpdate) = $ZDT($h,3,1)
    }Else{
		Set ..tsUpdate = $ZDT($h,3,1)
	}
	Return $$$OK
]]></Implementation>
</Method>

<Trigger name="triggerInsert">
<Code>	Set ({tsCreate},{tsUpdate}) = $ZDT($h,3,1)</Code>
<Event>INSERT</Event>
</Trigger>

<Trigger name="triggerUpdate">
<Code>	Set {tsUpdate} = $ZDT($h,3,1)</Code>
<Event>UPDATE</Event>
</Trigger>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Iris.Tools.MoniA859.GlobalSizeD</DataLocation>
<DefaultData>GlobalSizeDefaultData</DefaultData>
<IdLocation>^Iris.Tools.MoniA859.GlobalSizeD</IdLocation>
<IndexLocation>^Iris.Tools.MoniA859.GlobalSizeI</IndexLocation>
<StreamLocation>^Iris.Tools.MoniA859.GlobalSizeS</StreamLocation>
<Data name="GlobalSizeDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>database</Value>
</Value>
<Value name="3">
<Value>global</Value>
</Value>
<Value name="4">
<Value>allocatedInMB</Value>
</Value>
<Value name="5">
<Value>sizeDate</Value>
</Value>
<Value name="6">
<Value>recordType</Value>
</Value>
<Value name="7">
<Value>tsCreate</Value>
</Value>
<Value name="8">
<Value>tsUpdate</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Iris.Tools.Monitor.Rest.Size">
<Super>%CSP.REST</Super>
<TimeChanged>65708,48794.789129</TimeChanged>
<TimeCreated>65708,48794.789129</TimeCreated>

<Parameter name="CONTENTTYPE">
<Default>application/json</Default>
</Parameter>

<XData name="UrlMap">
<XMLNamespace>http://www.intersystems.com/urlmap</XMLNamespace>
<Data><![CDATA[
<Routes>
      <Route Url="/v1/dbsize" Method="GET" Call="getDBSize"/>
      <Route Url="/v1/test" Method="GET" Call="test"/>
      <Route Url="/v1/gsize" Method="GET" Call="getGSize"/>
      <Route Url="/v1/directorybyname/:databaseName" Method="GET" Call="getDirectoryByDBName"/>
      <Route Url="/v1/alldirectory" Method="GET" Call="getAllDirectory"/>
   </Routes>
]]></Data>
</XData>

<Method name="test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Write {"test":($zdt($h,3,1))}.%ToJSON()
	Return $$$OK
]]></Implementation>
</Method>

<Method name="getDBSize">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK
	Set directory = $Get(%request.Data("directory",1))
	Set recordType = $Get(%request.Data("recordType",1))
	Set startDate = $Get(%request.Data("startDate",1))
	Set endDate = $Get(%request.Data("endDate",1))
	
	Set:directory="" directory="*"
	Set:recordType="" recordType="Day"
	Set:startDate="" startDate=$zd($h,3)
	Set:endDate="" endDate=$zd($h,3)
	
	Set jsonResponse = ##class(Iris.Tools.Monitor.Services.DBSizeServices).get(directory,recordType,startDate,endDate)
	Write jsonResponse.%ToJSON()
	Return tSc
]]></Implementation>
</Method>

<Method name="getGSize">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK
	Set directory = $Get(%request.Data("directory",1))
	Set:directory="" directory="*"
	Set:directory["," directory = $Lfs(directory, ",")

	Set globals = $Get(%request.Data("global",1))
	Set recordType = $Get(%request.Data("recordType",1))
	Set startDate = $Get(%request.Data("startDate",1))
	Set endDate = $Get(%request.Data("endDate",1))
	Set max = +$Get(%request.Data("top",1), -1)
	Set:max=0 max = -1

	If max '= -1 {
		If (directory = "*") || $Lv(directory) {
			Set %response.Status=..#HTTP400BADREQUEST
			Quit $$$OK
		}
		Set globals = ##class(Iris.Tools.Monitor.Services.GlobalSizeServices).topGlobals(max, directory, "Day")
	}

	
	Set:globals="" globals="*"
	Set:recordType="" recordType="Day"
	Set:startDate="" startDate=$zd($h,3)
	Set:endDate="" endDate=$zd($h,3)
	
	Set jsonResponse = ##class(Iris.Tools.Monitor.Services.GlobalSizeServices).get(directory,globals,recordType,startDate,endDate)
	Write jsonResponse.%ToJSON()
	Return tSc
]]></Implementation>
</Method>

<Method name="getAllDirectory">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK, array = [], ptr = 0
	Set directoryList = ##class(Iris.Tools.Monitor.Services.DBSizeServices).getAllDB()
	While $listnext(directoryList,ptr,directory) {
		Do array.%Push(directory)
	}
	Set jsonResponse = { "directoryList" : (array) }
	Write jsonResponse.%ToJSON()
	Return tSc
]]></Implementation>
</Method>

<Method name="getDirectoryByDBName">
<ClassMethod>1</ClassMethod>
<FormalSpec>databaseName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK
	Set directory = ##class(Iris.Tools.Monitor.Services.DBSizeServices).getDbDirectory(databaseName)
	Set jsonResponse = { "database" : { "databaseName" : (databaseName),"directory" : (directory)}}
	Write jsonResponse.%ToJSON()
	Return tSc
]]></Implementation>
</Method>
</Class>


<Class name="Iris.Tools.Monitor.Services.DBSizeServices">
<TimeChanged>65708,48794.767525</TimeChanged>
<TimeCreated>65708,48794.767525</TimeCreated>

<Method name="getAllDB">
<Description>
Get a list of all database on this system.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Dao.DBSizeDAO).getAllDB()
]]></Implementation>
</Method>

<Method name="updateDBSize">
<ClassMethod>1</ClassMethod>
<FormalSpec>mask:%String="*"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Dao.DBSizeDAO).updateDBSizeInfo(mask)
]]></Implementation>
</Method>

<Method name="updateAllDBSize">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Dao.DBSizeDAO).updateDBSizeInfo("*")
]]></Implementation>
</Method>

<Method name="get">
<Description><![CDATA[
Usefull method to retrieve size of database, following filters : <br/><ul>
<li><b>database</b>: database directory ("*" are allowed for all databases).</li>
<li><b>recordType</b>: possible value Day,Week,Month,Year (see Iris.Tools.Monitor.Data.GlobalSize doc for more information).</li>
<li><b>startDate</b>: start date in %TimeStamp format</li>
<li><b>endDate</b>: end date in %TimeStamp format</li>
</ul>
Return a %DynamicArray for easy use in a rest call.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String="*",recordType:%String="Day",startDate:%TimeStamp={ $zd($h,3)},endDate:%TimeStamp={ $zd($h,3)}</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set startDateH = $zdh(startDate,3)
	Set endDateH = $zdh(endDate,3)
	Set tDynArray = ##class(Iris.Tools.Monitor.Dao.DBSizeDAO).get(.database,.recordType,.startDateH,.endDateH)
	Return tDynArray
]]></Implementation>
</Method>

<Method name="getAndExportToFile">
<Description><![CDATA[
Usefull method to retrieve size of database, following filters are available : <br/><ul>
<li><b>filename</b>: file path to export csv file.</li>
<li><b>database</b>: database directory ("*" are allowed for all databases).</li>
/ <li><b>recordType</b>: possible value Day,Week,Month,Year (see Iris.Tools.Monitor.Data.GlobalSize doc for more information).</li>
<li><b>startDate</b>: start date in %TimeStamp format</li>
<li><b>startDate</b>: start date in %TimeStamp format</li>
</ul>
Return a %DynamicArray for easy use in a rest call.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,database:%String="*",recordType:%String="Day",startDate:%TimeStamp={ $zd($h,3)},endDate:%TimeStamp={ $zd($h,3)}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set startDateH = $zdh(startDate,3)
	Set endDateH = $zdh(endDate,3)
	Set sc = ##class(Iris.Tools.Monitor.Dao.DBSizeDAO).exportToFile(.filename,.database,.recordType,.startDateH,.endDateH)
	Return sc
]]></Implementation>
</Method>

<Method name="exportSizeToFile">
<Description>
Export size to the given filename for a date.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,date:%TimeStamp,recordType:%String="Day"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set dateH = $zdh(date,3)
	Set sc = ##class(Iris.Tools.Monitor.Dao.DBSizeDAO).exportToFile(filename,"*",recordType,dateH,dateH)
	Return sc
]]></Implementation>
</Method>

<Method name="getDbDirectory">
<Description>
Return the database directory for a database name.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>databaseName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ns = $namespace, dbDirectory = ""
	Try {
		Set $namespace = "%SYS"
		Set dbDirectory = ##class(Config.Databases).GetDirectory(databaseName)
		Set $namespace = ns
	}Catch(ex) {
		Set $namespace = ns
		Throw ex
	}
	Return dbDirectory
]]></Implementation>
</Method>

<Method name="clean">
<ClassMethod>1</ClassMethod>
<FormalSpec>retDay:%Integer=90,retWeek:%Integer=24,retMonth:%Integer=-1,retYear:%Integer=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Dao.DBSizeDAO).clean(retDay,retWeek,retMonth,retYear)
]]></Implementation>
</Method>
</Class>


<Class name="Iris.Tools.Monitor.Services.GlobalSizeServices">
<TimeChanged>65708,48794.77828</TimeChanged>
<TimeCreated>65708,48794.77828</TimeCreated>

<Method name="getAllocatedInMB">
<Description><![CDATA[
Return the size in MB of a global<br/>
It's a calculate value by %Library.GlobalEdit (not a stored value in Iris.Tools.Monitor.Data.GlobalSize).
<b>database</b> must be a direcotry not a database name.<br/>
call <b>getDbDirectory</b> to retrieve the database directory from a database name.<br/>
]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String,global:%String</FormalSpec>
<ReturnType>%Float</ReturnType>
<Implementation><![CDATA[
	Set allocated = 0
	Set sc = ##class(%Library.GlobalEdit).GetGlobalSize(.database,.global,.allocated,,1)
	If $$$ISERR(sc) $$$ThrowStatus(sc)
	Return allocated
]]></Implementation>
</Method>

<Method name="getAllDB">
<Description>
Get a list of all database on this system.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Services.DBSizeServices).getAllDB()
]]></Implementation>
</Method>

<Method name="updateAllDBGlobalSize">
<Description>
Update GlobalSize table for all databases and globals.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ..updateDatabasesGlobalSize(..getAllDB())
]]></Implementation>
</Method>

<Method name="get">
<Description><![CDATA[
Usefull method to retrieve size of global data, following filters : <br/><ul>
<li><b>database</b>: database directory ("*" are allowed for all databases).</li>
<li><b>global</b>: global name (with the "^" character, "*" are allowed for all globals)</li>
<li><b>recordType</b>: possible value Day,Week,Month,Year (see Iris.Tools.Monitor.Data.GlobalSize doc for more information).</li>
<li><b>startDate</b>: start date in %TimeStamp format</li>
<li><b>endDate</b>: end date in %TimeStamp format</li>
</ul>
Return a %DynamicArray for easy use in a rest call.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String="*",global:%String="*",recordType:%String="Day",startDate:%TimeStamp={ $zd($h,3)},endDate:%TimeStamp={ $zd($h,3)}</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	Set startDateH = $zdh(startDate,3)
	Set endDateH = $zdh(endDate,3)
	Set tDynArray = ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).get(.database,.global,.recordType,.startDateH,.endDateH)
	Return tDynArray
]]></Implementation>
</Method>

<Method name="topGlobals">
<ClassMethod>1</ClassMethod>
<FormalSpec>top:%Integer,database:%String,recordType:%String="Day"</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).getTopGlobals(top, database, recordType)
]]></Implementation>
</Method>

<Method name="getAndExportToFile">
<Description><![CDATA[
Usefull method to retrieve size of global data, following filters : <br/><ul>
<li><b>filename</b>: file path to export csv file.</li>
<li><b>database</b>: database directory ("*" are allowed for all databases).</li>
<li><b>global</b>: global name (with the "^" character, "*" are allowed for all globals)</li>
<li><b>recordType</b>: possible value Day,Week,Month,Year (see Iris.Tools.Monitor.Data.GlobalSize doc for more information).</li>
<li><b>startDate</b>: start date in %TimeStamp format</li>
<li><b>startDate</b>: start date in %TimeStamp format</li>
</ul>
Return a %DynamicArray for easy use in a rest call.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,database:%String="*",global:%String="*",recordType:%String="Day",startDate:%TimeStamp={ $zd($h,3)},endDate:%TimeStamp={ $zd($h,3)}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set startDateH = $zdh(startDate,3)
	Set endDateH = $zdh(endDate,3)
	Set sc = ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).exportToFile(.filename,.database,.global,.recordType,.startDateH,.endDateH)
	Return sc
]]></Implementation>
</Method>

<Method name="exportSizeToFile">
<Description>
Export global size to the given filename for a date.
It's an export for recordType "Day".</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,date:%TimeStamp,recordType:%String="Day"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set dateH = $zdh(date,3)
	Set sc = ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).exportToFile(filename,"*","*",recordType,dateH,dateH)
	Return sc
]]></Implementation>
</Method>

<Method name="setDecimalPointIsComma">
<Description><![CDATA[
Set a custom special variable for change decimal separator to a comma.<br/>
Currently this variable is used only for csv export file.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>setFlag:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set %ZDecimalPointIsComma=setFlag
	Return $$$OK
]]></Implementation>
</Method>

<Method name="updateDatabasesGlobalSize">
<Description>
Update GlobalSize table for a list of databases.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>databases:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ptr = 0, sc = $$$OK
	While $Listnext(databases,ptr,database) {
		If (database'["lib") {	; temp fix (protect error with enslib)
			$$$TOE(sc,..updateDatabaseGlobalSize(database))
		}
	}
	Return sc
]]></Implementation>
</Method>

<Method name="updateDatabaseGlobalSize">
<Description>
Update GlobalSize table for a database</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set sizeDate = +$h
	Do ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).clearGblListCache(database)
	Set global = ""
	For  {
		Set global = ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).getNextGlobal(database,.global)
		Quit:global=""
		Set allocatedInMB = ..getAllocatedInMB(database,.global)
		$$$TOE(sc,..setRecordSize("Day",database,.global,.allocatedInMB,.sizeDate))
		$$$TOE(sc,..setRecordSize("Week",database,.global,.allocatedInMB,.sizeDate))
		$$$TOE(sc,..setRecordSize("Month",database,.global,.allocatedInMB,.sizeDate))
		$$$TOE(sc,..setRecordSize("Year",database,.global,.allocatedInMB,.sizeDate))
	}
	Return sc
]]></Implementation>
</Method>

<Method name="getGlobalListForDB">
<Description>
Return all existing global in a database directory.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>database:%String</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).getGlobalList(.database)
]]></Implementation>
</Method>

<Method name="setRecordSize">
<ClassMethod>1</ClassMethod>
<FormalSpec>recordType:%String,database:%String="",global:%String,allocatedInMB:%Float,sizeDate:%Date=+$h</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).setSize(.recordType,.database,.global,.allocatedInMB,.sizeDate)
]]></Implementation>
</Method>

<Method name="getDbDirectory">
<Description><![CDATA[
Return the database directory for a database name.<br/>
deprecated use : ##class(Iris.Tools.Monitor.Services.DBSizeServices).getDbDirectory(databaseName)]]></Description>
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>databaseName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Services.DBSizeServices).getDbDirectory(databaseName)
]]></Implementation>
</Method>

<Method name="clean">
<ClassMethod>1</ClassMethod>
<FormalSpec>retDay:%Integer=90,retWeek:%Integer=24,retMonth:%Integer=-1,retYear:%Integer=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Return ##class(Iris.Tools.Monitor.Dao.GlobalSizeDAO).clean(retDay,retWeek,retMonth,retYear)
]]></Implementation>
</Method>
</Class>


<Class name="Iris.Tools.Monitor.Tasks.Projection">
<Super>%Projection.AbstractProjection</Super>
<TimeChanged>65708,48794.799327</TimeChanged>
<TimeCreated>65708,48794.799327</TimeCreated>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $namespace
    Do ##class(Iris.Tools.Monitor.Tasks.UpdateSize).installTask()
    Set oldNs = $namespace
    Set $namespace = "%SYS"
    set webName = "/csp/globaltracing"
    Quit:##class(Security.Applications).Exists(webName) $$$OK
    set webProperties("NameSpace") = oldNs
    set webProperties("Enabled") = 1
    set webProperties("CSPZENEnabled") = 1
    set webProperties("AutheEnabled") = 64
    set webProperties("iKnowEnabled") = 0
    set webProperties("DeepSeeEnabled") = 0
    Set webProperties("DispatchClass")="Iris.Tools.Monitor.Rest.Size"
    Set webProperties("MatchRoles")=":%DB_%DEFAULT"
    set sc = ##class(Security.Applications).Create(webName, .webProperties)
    write "Web application "_webName_" creation status : ", $SYSTEM.Status.GetOneErrorText(sc),! 
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $namespace
    Set $namespace = "%SYS"
    set webName = "/csp/globaltracing"
    Quit:'##class(Security.Applications).Exists(webName) $$$OK
    Do ##class(Security.Applications).Delete(webName)
	QUIT $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Iris.Tools.Monitor.Tasks.UpdateSize">
<Description><![CDATA[
Task used for update data of growth of global size<br/>
Should be performed every day.]]></Description>
<Super>%SYS.Task.Definition</Super>
<TimeChanged>65708,48794.805745</TimeChanged>
<TimeCreated>65708,48794.805745</TimeCreated>

<Projection name="autoDeploy">
<Type>Iris.Tools.Monitor.Tasks.Projection</Type>
</Projection>

<Parameter name="TaskName">
<Default>Global Size Updater</Default>
</Parameter>

<Property name="latestSizeFile">
<Description>
If a filename is set, a csv file will be created with the last gobal size update.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="256"/>
</Property>

<Property name="latestDBSizeFile">
<Description>
If a filename is set, a csv file will be created with the last database size update.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="256"/>
</Property>

<Property name="decimalPointIsComma">
<Description>
If true, decimal separator is "," in csv file</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="dbList">
<Description><![CDATA[
if not empty, global size will be performed only for listed database<br/>
ex: /opt/irisapp/data/,/usr/irissys/mgr/user/ <br/>]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
</Property>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK
	Try {
		$$$TOE(sc,..cmTask(..latestSizeFile,..latestDBSizeFile,..decimalPointIsComma,..dbList))
	}Catch(ex) {
		Set tSc = ex.AsStatus()
	}
	Return tSc
]]></Implementation>
</Method>

<Method name="cmTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>latestSizeFile:%String="",latestDBSizeFile:%String="",decimalPointIsComma:%Boolean=0,dbList:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK
	Try {
		$$$TOE(tSc,##class(Iris.Tools.Monitor.Services.DBSizeServices).updateAllDBSize())
		If dbList = "" {
			$$$TOE(tSc,##class(Iris.Tools.Monitor.Services.GlobalSizeServices).updateAllDBGlobalSize())
		} Else {
			Set list = $Listfromstring(dbList, "," )
			$$$TOE(tSc,##class(Iris.Tools.Monitor.Services.GlobalSizeServices).updateDatabasesGlobalSize(list))
		}
		Do:+decimalPointIsComma ##class(Iris.Tools.Monitor.Services.GlobalSizeServices).setDecimalPointIsComma(1)
		If (latestSizeFile'="") {
			$$$TOE(tSc,##class(Iris.Tools.Monitor.Services.GlobalSizeServices).exportSizeToFile(latestSizeFile,$zd($h,3)))
		}
		If (latestDBSizeFile'="") {
			$$$TOE(tSc,##class(Iris.Tools.Monitor.Services.DBSizeServices).exportSizeToFile(latestDBSizeFile,$zd($h,3)))
		}
		$$$TOE(tSc,##class(Iris.Tools.Monitor.Services.GlobalSizeServices).clean())
		$$$TOE(tSc,##class(Iris.Tools.Monitor.Services.DBSizeServices).clean())
	}Catch(ex) {
		Set tSc = ex.AsStatus()
	}
	Return tSc
]]></Implementation>
</Method>

<Method name="installTask">
<Description>
Install the task for execution every day at 11:00 p.m.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSc = $$$OK
	Set id = $Get(^monitor.tasks.UpdateSize.id)
	Return:(id'="")&&(##class(%SYS.Task).%ExistsId(id)) $$$ERROR($$$GeneralError,$$$FormatText("Task already exist with id %1",id))
	Set task = ##class(%SYS.Task).%New()
	Set task.DailyFrequency = 0
	Set task.DailyFrequencyTime = ""
	Set task.DailyIncrement = ""
	Set task.DailyStartTime = 1*3600	; 1:00 a.m.
	Set task.DailyEndTime = ""
	Set task.TimePeriod = 0
	Set task.TimePeriodEvery = 1
	Set task.Description = "Update table with all globals size"
	Set task.TaskClass = ..%ClassName(1)
	Set task.NameSpace = $namespace
	Set task.Name = ..#TaskName
	Set tSc = task.%Save()
	Set:$$$ISOK(tSc) ^monitor.tasks.UpdateSize.id=task.%Id()
	Return tSc
]]></Implementation>
</Method>
</Class>
</Export>
